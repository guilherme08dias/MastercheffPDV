-- Enable UUID extension
create extension if not exists "uuid-ossp";

-- Profiles (linked to auth.users)
create table if not exists public.profiles (
  id uuid references auth.users not null primary key,
  email text,
  role text default 'cashier',
  full_name text
);

-- Products
create table if not exists public.products (
  id uuid default uuid_generate_v4() primary key,
  name text not null,
  category text not null, -- 'xis', 'dog', 'bebida', etc.
  price numeric not null,
  is_available boolean default true,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Neighborhoods
create table if not exists public.neighborhoods (
  id uuid default uuid_generate_v4() primary key,
  name text not null,
  delivery_fee numeric default 0,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Tags (for notes)
create table if not exists public.tags (
  id uuid default uuid_generate_v4() primary key,
  label text not null
);

-- Shifts
create table if not exists public.shifts (
  id uuid default uuid_generate_v4() primary key,
  opened_at timestamp with time zone default timezone('utc'::text, now()) not null,
  closed_at timestamp with time zone,
  initial_float numeric default 0,
  status text default 'open' -- 'open', 'closed'
);

-- Orders
create table if not exists public.orders (
  id bigint generated by default as identity primary key,
  shift_id uuid references public.shifts(id),
  customer_name text,
  type text not null, -- 'local', 'takeaway', 'delivery'
  neighborhood_id uuid references public.neighborhoods(id),
  delivery_fee_snapshot numeric default 0,
  payment_method text, -- 'cash', 'credit', 'debit', 'pix'
  total numeric not null,
  status text default 'pending', -- 'pending', 'completed', 'canceled'
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Order Items
create table if not exists public.order_items (
  id bigint generated by default as identity primary key,
  order_id bigint references public.orders(id),
  product_id uuid references public.products(id),
  quantity integer not null,
  unit_price numeric not null,
  notes text
);

-- RLS Policies (Simplified for now - allow all for authenticated)
alter table public.profiles enable row level security;
alter table public.products enable row level security;
alter table public.neighborhoods enable row level security;
alter table public.tags enable row level security;
alter table public.shifts enable row level security;
alter table public.orders enable row level security;
alter table public.order_items enable row level security;

-- Policies (using DO block to avoid errors if they exist)
do $$
begin
    if not exists (select 1 from pg_policies where policyname = 'Public profiles are viewable by everyone.') then
        create policy "Public profiles are viewable by everyone." on public.profiles for select using (true);
    end if;
    if not exists (select 1 from pg_policies where policyname = 'Users can insert their own profile.') then
        create policy "Users can insert their own profile." on public.profiles for insert with check (auth.uid() = id);
    end if;
    if not exists (select 1 from pg_policies where policyname = 'Users can update own profile.') then
        create policy "Users can update own profile." on public.profiles for update using (auth.uid() = id);
    end if;
    
    -- Generic authenticated access
    if not exists (select 1 from pg_policies where policyname = 'Enable all access for authenticated users' and tablename = 'products') then
        create policy "Enable all access for authenticated users" on public.products for all using (auth.role() = 'authenticated');
    end if;
    if not exists (select 1 from pg_policies where policyname = 'Enable all access for authenticated users' and tablename = 'neighborhoods') then
        create policy "Enable all access for authenticated users" on public.neighborhoods for all using (auth.role() = 'authenticated');
    end if;
    if not exists (select 1 from pg_policies where policyname = 'Enable all access for authenticated users' and tablename = 'tags') then
        create policy "Enable all access for authenticated users" on public.tags for all using (auth.role() = 'authenticated');
    end if;
    if not exists (select 1 from pg_policies where policyname = 'Enable all access for authenticated users' and tablename = 'shifts') then
        create policy "Enable all access for authenticated users" on public.shifts for all using (auth.role() = 'authenticated');
    end if;
    if not exists (select 1 from pg_policies where policyname = 'Enable all access for authenticated users' and tablename = 'orders') then
        create policy "Enable all access for authenticated users" on public.orders for all using (auth.role() = 'authenticated');
    end if;
    if not exists (select 1 from pg_policies where policyname = 'Enable all access for authenticated users' and tablename = 'order_items') then
        create policy "Enable all access for authenticated users" on public.order_items for all using (auth.role() = 'authenticated');
    end if;
end
$$;

-- Trigger for new users
create or replace function public.handle_new_user() 
returns trigger as $$
begin
  insert into public.profiles (id, email, role, full_name)
  values (new.id, new.email, 'cashier', new.raw_user_meta_data->>'full_name');
  return new;
end;
$$ language plpgsql security definer;

drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();
