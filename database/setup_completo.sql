-- ============================================================================
-- SCRIPT COMPLETO DE CONFIGURAÇÃO DO BANCO DE DADOS - XISMASTER
-- ============================================================================
-- Este script contém todas as tabelas, políticas de segurança (RLS) e funções
-- necessárias para rodar o sistema. Execute-o no SQL Editor do Supabase.
-- ============================================================================

-- 1. Habilitar Extensões
create extension if not exists "uuid-ossp";

-- 2. Perfis de Usuário (Vinculado ao Auth do Supabase)
create table if not exists public.profiles (
  id uuid references auth.users not null primary key,
  email text,
  role text default 'cashier',
  full_name text
);

-- 3. Produtos
create table if not exists public.products (
  id uuid default uuid_generate_v4() primary key,
  name text not null,
  category text not null, -- 'xis', 'dog', 'bebida', etc.
  price numeric not null,
  is_available boolean default true,
  menu_number integer, -- Número do cardápio
  description text,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- 4. Bairros (Taxas de Entrega)
create table if not exists public.neighborhoods (
  id uuid default uuid_generate_v4() primary key,
  name text not null,
  delivery_fee numeric default 0,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- 5. Tags (Observações Rápidas)
create table if not exists public.tags (
  id uuid default uuid_generate_v4() primary key,
  label text not null
);

-- 6. Turnos (Caixa)
create table if not exists public.shifts (
  id uuid default uuid_generate_v4() primary key,
  opened_at timestamp with time zone default timezone('utc'::text, now()) not null,
  closed_at timestamp with time zone,
  initial_float numeric default 0,
  status text default 'open' -- 'open', 'closed'
);

-- 7. Pedidos
create table if not exists public.orders (
  id bigint generated by default as identity primary key,
  shift_id uuid references public.shifts(id),
  customer_name text,
  type text not null, -- 'local', 'takeaway', 'delivery'
  neighborhood_id uuid references public.neighborhoods(id),
  delivery_fee_snapshot numeric default 0,
  payment_method text, -- 'cash', 'credit', 'debit', 'pix'
  total numeric not null,
  status text default 'pending', -- 'pending', 'completed', 'canceled'
  daily_number integer, -- Número sequencial do pedido no turno
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Garantir que a coluna daily_number exista (caso a tabela já tenha sido criada antes)
do $$
begin
  if not exists (select 1 from information_schema.columns where table_name = 'orders' and column_name = 'daily_number') then
    alter table public.orders add column daily_number integer;
  end if;
end $$;

-- 8. Itens do Pedido
create table if not exists public.order_items (
  id bigint generated by default as identity primary key,
  order_id bigint references public.orders(id),
  product_id uuid references public.products(id),
  quantity integer not null,
  unit_price numeric not null,
  notes text
);

-- 9. Despesas (Novo Módulo)
CREATE TABLE IF NOT EXISTS expenses (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    category TEXT NOT NULL CHECK (category IN ('energia', 'contador', 'salarios', 'mercado', 'embalagens', 'gas', 'hamburguer', 'pao', 'outros')),
    description TEXT,
    amount DECIMAL(10, 2) NOT NULL,
    expense_date DATE NOT NULL DEFAULT CURRENT_DATE,
    shift_id UUID REFERENCES shifts(id) ON DELETE SET NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    created_by UUID REFERENCES profiles(id)
);

-- Índices para Despesas
CREATE INDEX IF NOT EXISTS idx_expenses_date ON expenses(expense_date);
CREATE INDEX IF NOT EXISTS idx_expenses_category ON expenses(category);
CREATE INDEX IF NOT EXISTS idx_expenses_shift ON expenses(shift_id);

-- Garantir que colunas novas na tabela expenses existam (caso a tabela já tenha sido criada antes)
do $$
begin
  if not exists (select 1 from information_schema.columns where table_name = 'expenses' and column_name = 'shift_id') then
    alter table public.expenses add column shift_id UUID REFERENCES shifts(id) ON DELETE SET NULL;
  end if;
  if not exists (select 1 from information_schema.columns where table_name = 'expenses' and column_name = 'created_by') then
    alter table public.expenses add column created_by UUID REFERENCES profiles(id);
  end if;
end $$;

-- ============================================================================
-- SEGURANÇA (RLS - Row Level Security)
-- ============================================================================

-- Habilitar RLS em todas as tabelas
alter table public.profiles enable row level security;
alter table public.products enable row level security;
alter table public.neighborhoods enable row level security;
alter table public.tags enable row level security;
alter table public.shifts enable row level security;
alter table public.orders enable row level security;
alter table public.order_items enable row level security;
alter table public.expenses enable row level security;

-- Remover políticas antigas para evitar conflitos (Limpeza)
drop policy if exists "Public profiles are viewable by everyone." on public.profiles;
drop policy if exists "Users can update own profile." on public.profiles;
drop policy if exists "Enable all access for authenticated users" on public.products;
drop policy if exists "Enable all access for authenticated users" on public.neighborhoods;
drop policy if exists "Enable all access for authenticated users" on public.tags;
drop policy if exists "Enable all access for authenticated users" on public.shifts;
drop policy if exists "Enable all access for authenticated users" on public.orders;
drop policy if exists "Enable all access for authenticated users" on public.order_items;
drop policy if exists "Enable all access for authenticated users" on public.expenses;

-- Criar Políticas Permissivas (Usuários logados podem ler/escrever tudo no sistema)
-- Ideal para sistemas internos onde todo usuário logado é funcionário.

create policy "Public profiles are viewable by everyone." on public.profiles for select using (true);
create policy "Users can update own profile." on public.profiles for update using (auth.uid() = id);

create policy "Enable all access for authenticated users" on public.products for all using (auth.role() = 'authenticated');
create policy "Enable all access for authenticated users" on public.neighborhoods for all using (auth.role() = 'authenticated');
create policy "Enable all access for authenticated users" on public.tags for all using (auth.role() = 'authenticated');
create policy "Enable all access for authenticated users" on public.shifts for all using (auth.role() = 'authenticated');
create policy "Enable all access for authenticated users" on public.orders for all using (auth.role() = 'authenticated');
create policy "Enable all access for authenticated users" on public.order_items for all using (auth.role() = 'authenticated');
create policy "Enable all access for authenticated users" on public.expenses for all using (auth.role() = 'authenticated');

-- ============================================================================
-- TRIGGERS E FUNÇÕES
-- ============================================================================

-- Trigger para criar perfil automaticamente ao cadastrar usuário no Auth
create or replace function public.handle_new_user() 
returns trigger as $$
begin
  insert into public.profiles (id, email, role, full_name)
  values (new.id, new.email, 'cashier', new.raw_user_meta_data->>'full_name');
  return new;
end;
$$ language plpgsql security definer;

drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- FIM DO SCRIPT
